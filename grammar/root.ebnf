root ::= small_stmt | compound_stmt
small_stmt ::= (drop_stmt | decl_stmt | return_stmt | yield_stmt | flow_ctrl_stmt | defer_stmt | import_stmt | type_stmt | single_expression) ";"?
compound_stmt ::= if_stmt | while_stmt | scope_stmt | fun_stmt
batch ::= "{" root* "}"

scope_stmt ::= "scoped" batch

return_stmt ::= "return" multi_expression?
yield_stmt ::= "yield" multi_expression?
import_stmt ::= "import" string ("as" identifier)?
flow_ctrl_stmt ::= ("break" | "continue") identifier?
defer_stmt ::= "defer" (single_expression | batch)

decl_stmt ::= "let" decl_stmt_signature ("," decl_stmt_signature)* ("=" multi_expression)?
decl_stmt_signature ::= "mut"? identifier type_definition?
drop_stmt ::= "drop" identifier ("," identifier)*

if_stmt ::= "if" single_expression batch else_if_stmt* else_stmt
else_if_stmt ::= "else" "if" single_expression batch
else_stmt ::= "else" batch

while_stmt ::= "while" single_expression batch

multi_expression ::= single_expression ("," single_expression)*
single_expression ::= expression_value (operator expression_value)* (member_access | member_invocation | member_subscript)*
expression_value ::= value | "(" "use" value ")"
value ::= number | "false" | "true" | "null" | string | regex | fun_value | object_value | array_value | tuple_value | identifier | "(" single_expression ")"
fun_value ::= "fun" parameter_decl type_definition? batch | "(" "fun" parameter_decl type_definition? "=>" multi_expression ")"
object_value ::= "{" (object_value_field ("," object_value_field)* ","?)? "}"
object_value_field ::= (string | identifier) "=" single_expression | "..." identifier
array_value ::= "[" number? "]" type "{" (single_expression ("," single_expression)*)? "}"
tuple_value ::= "(" single_expression ("," single_expression)+ ")" | "todo"

member_access ::= "?"? "." identifier
member_invocation ::= "?"? "(" ((identifier "=" exression | single_expression ("," single_expression)*) ("," identifier "=" single_expression)*)? ")"
member_subscript ::= "?"? "[" (subscript_slice | single_expression) "]"
subscript_slice ::= single_expression? ":" single_expression? (":" single_expression?)?

fun_stmt ::= "fun" identifier parameter_decl type_definition? batch
parameter_decl ::= "(" (identifier type_definition ("," identifier type_definition)* parameter_decl_default? ("," identifier type_definition parameter_decl_default)*)? ")"
parameter_decl_default ::= ("from" (identifier | object_value))? "=" single_expression

type_stmt ::= "type" identifier "=" chained_typed
type_definition ::= ":" chained_typed
type ::= tuple_type | single_type
chained_typed ::= type ("|" type)*
tuple_type ::= "(" chained_typed ("," chained_typed)* ")"
single_type ::= "[]"* (fun_type | object_type | identifier | tuple_type)
fun_type ::= "fun" parameter_decl type_definition
object_type ::= "{" (object_type_field ("," object_type_field)* ","?)? "}"
object_type_field ::= identifier type_definition | "..." identifier

error_stmt ::= "error" identifier "{" 
error_field ::= identifier parameter_decl? ("=" single_expression)?

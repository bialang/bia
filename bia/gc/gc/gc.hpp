#pragma once

#include "detail/container.hpp"
#include "memory_allocator.hpp"
#include "object.hpp"
#include "object_info.hpp"
#include "object_ptr.hpp"
#include "root.hpp"

#include <array>
#include <atomic>
#include <cstddef>
#include <cstdint>
#include <exception/implementation_error.hpp>
#include <memory>
#include <thread/spin_mutex.hpp>
#include <type_traits>
#include <util/gsl.hpp>
#include <util/type_traits/conjunction.hpp>
#include <utility>

namespace bia {
namespace gc {

/*
 A garbage collector highly optimized for the BVM. Using this collector for custom task is not recommended.

 @see memory_allocator
*/
class gc
{
public:
	/**
	 * A token generated by registering the current thread in the gc index. This token manages the gc root.
	 */
	class token
	{
	public:
		token(const token& copy) = delete;
		token(token&& move) noexcept : _gc(move._gc), _root(std::move(move._root))
		{
			move._gc = nullptr;
		}
		/**
		 * Destructor.
		 */
		~token() noexcept
		{
			// deregister from gc
			if (_gc) {
				_active_gc_instance = nullptr;
				_gc->_free_root(_root);
			}
		}
		/**
		 * Sets `dest` to `src`.
		 *
		 * @param[in,out] dest defines the destination
		 * @param src defines the source
		 */
		void set(object_ptr& dest, object_ptr& src) noexcept
		{
			set(dest, src.get());
		}
		/*
		 Sets the destination pointer to the source pointer. If the gc is active, additional work is done.

		 @param[out] dest defines the destination
		 @param src defines the source
		*/
		void set(object_ptr& dest, void* src) noexcept
		{
			// gc is active and dest could be possibly missed
			if (auto ptr = dest.template get<object_info>()) {
				(ptr - 1)->miss_index.store(_gc->_miss_index.load(std::memory_order_consume),
				                            std::memory_order_release);
			}

			dest.set(src);
		}
		/**
		 * Sets the @ref object_ptr at `index` in the root to `src`.
		 *
		 * @param index the index of the @ref object_ptr
		 * @param[in] src the source value
		 * @throw exception::bounds_error if the index is out of bounds
		 */
		void set(std::size_t index, void* src)
		{
			set(_root.at(index), src);
		}
		/**
		 * Returns the internal root object.
		 *
		 * @returns a reference to the root
		 */
		class root& root() noexcept
		{
			return _root;
		}

	private:
		friend gc;

		/* the parent gc */
		gc* _gc;
		/* the root */
		class root _root;

		/**
		 * Constructor.
		 *
		 * @param[in] gc the parent garbage collector
		 * @param count how much space for the root
		 * @throw see gc::_create_root()
		 */
		token(gc* gc, std::size_t count) : _gc(gc), _root(gc->_create_root(count))
		{}
	};
	template<typename T>
	class gcable
	{
	public:
		gcable(const gcable& copy) = delete;
		/**
		 * Move-Constructor.
		 *
		 * @post `move` will be invalid
		 *
		 * @param[in, out] move the move object
		 */
		gcable(gcable&& move) noexcept
		{
			_gc       = move._gc;
			_ptr      = move._ptr;
			move._gc  = nullptr;
			move._ptr = nullptr;
		}
		~gcable()
		{
			// discard if not monitored
			if (_gc) {
				_destroy(_ptr);
				_gc->_free(_ptr);
			}
		}
		/**
		 * Starts monitoring this buffer.
		 *
		 * @warning if the pointer has not been successfully saved to root or one of its children the pointer
		 * could be garbage collected
		 *
		 * @pre this object is valid
		 * @post this object invalid
		 */
		void start_monitor()
		{
			BIA_EXPECTS(valid());

			_gc->_register_gcable(_ptr);

			_gc  = nullptr;
			_ptr = nullptr;

			BIA_ENSURES(!valid());
		}
		/**
		 * Returns the gc pointer.
		 *
		 * @returns the pointer if this object is valid, otherwise `nullptr`
		 */
		T* peek() const noexcept
		{
			return _ptr;
		}
		/**
		 * Checks if this object is valid. If so the pointer can be retrieved and/or monitored.
		 *
		 * @returns `true` if valid, otherwise `false`
		 */
		bool valid() const noexcept
		{
			return _gc != nullptr;
		}

	private:
		friend gc;

		/** the parent gc */
		gc* _gc;
		/** the actual gcable pointer */
		T* _ptr;

		/**
		 * Constructor.
		 *
		 * @param[in] gc the gc parent
		 * @param[in] ptr the gcable pointer
		 */
		gcable(util::not_null<gc*> gc, util::not_null<T*> ptr) noexcept
		{
			_gc  = gc.get();
			_ptr = ptr.get();
		}
		/**
		 * Does nothing.
		 */
		static void _destroy(void*) noexcept
		{}
		/**
		 * Destroys the given object.
		 *
		 * @param ptr the pointer to the object
		 * @tparam Ty the type of the object
		 */
		template<typename Ty>
		static void _destroy(util::not_null<Ty*> ptr) noexcept
		{
			ptr->~Ty();
		}
	};

	/**
	 * Constructor.
	 *
	 * @param allocator provides the required memory for the allocations
	 */
	gc(util::not_null<std::shared_ptr<memory_allocator>> allocator) noexcept;
	/**
	 * Destructor.
	 */
	~gc();
	/**
	 *
	 */
	void thread_main();
	/**
	 * Blocks the current thread and runs the garbage collector. If an instance is already running, this
	 * function returns.
	 *
	 * @returns `true` if the gc was run, otherwise `false`
	 */
	bool run_once();
	/**
	 * Registeres the current thread. If this thread has already been registered, this function fails.
	 *
	 * @param count how much space the root should have
	 * @returns a token which deregisteres this thread upon destruction
	 */
	token register_thread(std::size_t count);
	/**
	 * Allocates gc monitorable memory. In order for this memory to be monitored by the garbage collector
	 * gcable::start_monitor() must be called.
	 *
	 * @param size the size of the memory
	 * @param zero (optional) whether the memory should be set to zero
	 * @returns the allocated buffer
	 * @throw see _allocate_impl()
	 */
	gcable<void> allocate(std::size_t size, bool zero = false);
	/**
	 * Allocates and constructs the given type with its arguments.
	 *
	 * @param args are forwarded to the constructor of *T*
	 * @returns the object
	 * @throw see _allocate_impl()
	 * @tparam T is the type that should be created
	 * @tparam Args are the argument types for the constructor
	 */
	template<typename T, typename... Args>
	typename std::enable_if<std::is_base_of<object, T>::value, gcable<T>>::type construct(Args&&... args)
	{
		static_assert(alignof(T) == object_alignment, "cannot have a different object alignment");

		return { this, new (_allocate_impl(sizeof(T), false).get()) T(std::forward<Args>(args)...) };
	}
	/**
	 * Returns the memory allocator of this garbage collector. Memory allocated through this allocator will
	 * not be garbage collected.
	 *
	 * @returns the internally used memory allocator
	 */
	const std::shared_ptr<memory_allocator>& allocator() noexcept;
	/**
	 * Returns the active gc of the current thread.
	 *
	 * @returns the current gc if set, otherwise `nullptr`
	 */
	static gc* active_gc() noexcept;

private:
	/** the currently active instance */
	static thread_local gc* _active_gc_instance;
	/** the memory allocator */
	std::shared_ptr<memory_allocator> _mem_allocator;
	/** the current gc mark */
	bool _current_mark = false;
	/** the current miss index; this value is used to prevent misfreeing objects */
	std::atomic_uint32_t _miss_index;
	/** is for ensuring only one gc instance is running; using this because try_lock does not fail spuriously
	 */
	thread::spin_mutex _mutex;
	/** holds every allocated element */
	detail::container<object_info*> _allocated;
	/** holds every created root */
	detail::container<root> _roots;

	/**
	 * Allocates gc monitorable memory.
	 *
	 * @param size the size of the memory region
	 * @param leaf whether this gc object can have more gc monitored objects
	 * @returns the memory buffer
	 * @throw see memory_allocator::checked_allocate()
	 */
	util::not_null<void*> _allocate_impl(std::size_t size, bool leaf);
	/**
	 * Deallocates the pointer allocated by _allocate_impl().
	 *
	 * @param ptr the pointer
	 * @throw see memory_allocator::deallocate()
	 */
	void _free(util::not_null<void*> ptr);
	/**
	 * Starts monitoring this pointer.
	 *
	 * @pre `ptr` must be allocated by _allocate_impl() and not freed
	 *
	 * @param ptr the gcable pointer
	 */
	void _register_gcable(util::not_null<void*> ptr);
	root _create_root(std::size_t count);
	void _free_root(root root);
};

} // namespace gc
} // namespace bia